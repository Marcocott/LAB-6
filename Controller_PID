LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

ENTITY Controller_PID IS
	PORT (Clk, RSTn, Start : IN STD_LOGIC;
			Data_in : IN SIGNED ( 7 DOWNTO 0);
			Done_sign : OUT STD_LOGIC ;
			Out_MEM_B : OUT SIGNED ( 7 DOWNTO 0 ));
END Controller_PID;

ARCHITECTURE Structure OF Controller_PID IS
	COMPONENT RAM1024x8 IS
		PORT ( Address: in std_logic_vector(9 downto 0);
				 Data_in: in SIGNED(7 downto 0);
				 CS, RD_WRn, Clk: in std_logic;
				 Data_out: out SIGNED(7 downto 0));
	END COMPONENT;
	
	COMPONENT mux_4to1_10bit IS
		PORT (  x , y , u , v  : IN SIGNED (9 DOWNTO 0);
				 s : IN STD_LOGIC_VECTOR (1 DOWNTO 0);
				 m : OUT SIGNED (9 DOWNTO 0) );
	END COMPONENT;
	
	COMPONENT counter IS
		PORT ( resetn, enable, load, U_Dn : IN STD_LOGIC;
				 clock :IN STD_LOGIC;
				 data_in : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
				 count : OUT STD_LOGIC_VECTOR(9 DOWNTO 0));
	END COMPONENT;
	
	COMPONENT sommatore IS
		PORT ( X, Y: IN SIGNED (19 DOWNTO 0);
				 S: OUT SIGNED (19 DOWNTO 0);
				 SUB_ADDn : IN STD_LOGIC);
	END COMPONENT;
	
	COMPONENT regn_20bit IS
		GENERIC ( N : integer:=20);
		
		PORT (R : IN SIGNED(N-1 DOWNTO 0);
				Clock, Resetn, Enable : IN STD_LOGIC;
				Q : OUT SIGNED(N-1 DOWNTO 0));
	END COMPONENT;
	
	COMPONENT regn_8bit IS
		GENERIC ( N : integer:=8);
		
		PORT (R : IN SIGNED(N-1 DOWNTO 0);
				Clock, Resetn, Enable : IN STD_LOGIC;
				Q : OUT SIGNED(N-1 DOWNTO 0));
	END COMPONENT;
	
	
	COMPONENT Mux2to1_8bit IS
		PORT (x, y: IN SIGNED( 7 DOWNTO 0 );
					s: IN STD_LOGIC;
					m: OUT SIGNED( 7 DOWNTO 0 ));
	END COMPONENT;
	
	COMPONENT Mux_2to1_10bit IS
		PORT (x, y: IN STD_LOGIC_VECTOR( 9 DOWNTO 0 );
					s: IN STD_LOGIC;
					m: OUT STD_LOGIC_VECTOR( 9 DOWNTO 0 ));
	END COMPONENT;
	
	SIGNAL EN_C1, EN_C2, CS_MEM_A, CS_MEM_B,  EN_R_8bit, RD_WRn_MEM_A, RD_WRn_MEM_B, L_C2, RSTn_R_20bit, SUB_ADDn,   --EN_R_20bit,
			 MUX_Sel_Counters, XOR_13bit , XOR_2bit, Sel_Mux_k_1: STD_LOGIC;
			 
	SIGNAL MUX_Sel_adder : STD_LOGIC_VECTOR ( 1 DOWNTO 0 );
	
	SIGNAL Out_C1, Out_C2, Add_MEM_A : STD_LOGIC_VECTOR ( 9 DOWNTO 0 );
	
	SIGNAL Out_MEM_A, Out_R_8bit, Out_Mux_Saturation, Out_Mux_Signed_Sat, In_R_8bit : SIGNED ( 7 DOWNTO 0 );
	
	SIGNAL Sum, Out_R_20bit : SIGNED ( 19 DOWNTO 0 );
	
	SIGNAL twoEk, fourEk, quarterEk, halfEk_1, Out_Mux_adder: SIGNED ( 9 DOWNTO 0 );
	
	SIGNAL Out_Mux_adder_20bit: SIGNED ( 19 DOWNTO 0 );
	
	TYPE State_type IS (IDLE, WR_MEM_A, PROP_CONTR_0, PROP_CONTR_1, PROP_CONTR_2, INT_CONTR_0, INT_CONTR, DIFF_CONTR, WR_MEM_B, DONE, RD_MEM_B);
	SIGNAL PRESENT_STATE, NEXT_STATE : State_type;
	
	
	BEGIN
	
	Counter1 : counter PORT MAP ( Resetn => RSTn, Enable => EN_C1, Load => '0', U_Dn => '1', Clock => Clk, Data_in => "0000000000", count => Out_C1 );
	Counter2 : counter PORT MAP ( Resetn => RSTn, Enable => EN_C2, Load => L_C2, U_Dn => '0', Clock => Clk, Data_in => Out_C1, count => Out_C2 );
	
	Mux_Counters : Mux_2to1_10bit PORT MAP ( x => Out_C1, y => Out_C2, s => MUX_Sel_Counters, m => Add_MEM_A );
	 
	MEM_A : RAM1024x8 PORT MAP ( Address => Add_MEM_A, Data_in => Data_in, CS => CS_MEM_A , RD_WRn => RD_WRn_MEM_A, Clk => Clk, Data_out => Out_MEM_A );
	
	R_8bit : regn_8bit PORT MAP ( R => Out_MEM_A, Clock => Clk, Resetn => RSTn, Enable => EN_R_8bit, Q => Out_R_8bit );
	 
	Sel_Mux_k_1 <= ( Out_C1(0) OR Out_C1(1) OR Out_C1(2) OR Out_C1(3) OR Out_C1(4) OR Out_C1(5) OR Out_C1(6) OR Out_C1(7) OR Out_C1(8) OR Out_C1(9));
	
	Mux_k_1 : Mux2to1_8bit PORT MAP ( x => "00000000", y => Out_MEM_A, s => Sel_Mux_k_1, m => In_R_8bit );
	
	twoEk <= (Out_MEM_A(7) & Out_MEM_A & '0' );
	fourEk<= ( Out_MEM_A & "00" );
	quarterEk <= (Out_MEM_A(7) & Out_MEM_A(7) & Out_MEM_A(7) & Out_MEM_A(7) & Out_MEM_A(7 DOWNTO 2) );
	halfEk_1 <= ( Out_R_8bit(7) & Out_R_8bit(7) & Out_R_8bit(7)& Out_R_8bit(7 DOWNTO 1) );
	
	Mux_adder : Mux_4to1_10bit PORT MAP ( x => twoEk, y => fourEk, u => quarterEk, v => halfEk_1, s => MUX_Sel_adder , m => Out_Mux_adder );
	
	Out_Mux_adder_20bit <= ( Out_Mux_adder(7) & Out_Mux_adder(7) & Out_Mux_adder(7) & Out_Mux_adder(7) & Out_Mux_adder(7) & Out_Mux_adder(7) & Out_Mux_adder(7) & Out_Mux_adder(7) & Out_Mux_adder(7) & Out_Mux_adder(7)& Out_Mux_adder );
	
	add : sommatore PORT MAP ( X => Out_R_20bit, Y => Out_Mux_adder_20bit, S => Sum, SUB_ADDn => SUB_ADDn );
	
	R_20bit :regn_20bit PORT MAP ( R => Sum, Clock => Clk, Resetn => RSTn_R_20bit, Enable => '1', Q => Out_R_20bit );
	
	Mux_Saturation : Mux2to1_8bit PORT MAP ( x => Out_R_20bit( 7 DOWNTO 0 ), y => Out_Mux_Signed_Sat , s => XOR_13bit, m => Out_Mux_Saturation );
	
	--XOR_13bit <= (Out_R_20bit(19) XOR Out_R_20bit(18) XOR Out_R_20bit(17) XOR Out_R_20bit(16) XOR Out_R_20bit(15) XOR Out_R_20bit(14) XOR Out_R_20bit(13) XOR Out_R_20bit(12) XOR Out_R_20bit(11) XOR Out_R_20bit(10) XOR Out_R_20bit(9) XOR Out_R_20bit(8) Xor Out_R_20bit (7));
	
	XOR_13bit <= (Out_R_20bit(19) OR Out_R_20bit(18) OR Out_R_20bit(17) OR Out_R_20bit(16) OR Out_R_20bit(15) OR Out_R_20bit(14) OR Out_R_20bit(13) OR Out_R_20bit(12) OR Out_R_20bit(11) OR Out_R_20bit(10) OR Out_R_20bit(9) OR Out_R_20bit(8) or Out_R_20bit (7)) AND 
	   (not (Out_R_20bit(19) AND Out_R_20bit(18) AND Out_R_20bit(17) AND Out_R_20bit(16) AND Out_R_20bit(15) AND Out_R_20bit(14) AND Out_R_20bit(13) AND Out_R_20bit(12) AND Out_R_20bit(11) AND Out_R_20bit(10) AND Out_R_20bit(9) AND Out_R_20bit(8) AND Out_R_20bit (7)));
	
	XOR_2bit <= XOR_13bit XOR  Out_R_20bit(19) ;
	
	Mux_Signed_Sat : Mux2to1_8bit PORT MAP ( x => "10000000", y =>"01111111", s => XOR_2bit, m => Out_Mux_Signed_Sat );
	
	MEM_B : RAM1024x8 PORT MAP ( Address => Out_C1, Data_in => Out_Mux_Saturation, CS => CS_MEM_B , RD_WRn => RD_WRn_MEM_B, Clk => Clk, Data_out => Out_MEM_B );
	
	
	
	
			FSM_transitions: PROCESS ( Rstn, Clk )
			
				BEGIN
					if RSTn = '0' then 
					 PRESENT_STATE <= idle;
					else
						if clk'event and clk = '1' then -- flip - flop transition when rising edge occurs
							PRESENT_STATE <= NEXT_STATE;
						end if;
					end if;
				
			END PROCESS ;
			
			next_state_evaluation: process(PRESENT_STATE, start, out_c1, out_c2)
				BEGIN
					
					case PRESENT_STATE is
					  when IDLE => if Start = '0' then
											next_state <= IDLE;
										else
											next_state <= WR_MEM_A;
										end if;
					
					  when WR_MEM_A => if  Out_C1 = "1111111111" then
											next_state <= PROP_CONTR_0;
										else
											next_state <= WR_MEM_A;
										end if;
										
					  when  PROP_CONTR_0 => next_state <= PROP_CONTR_1;
					  
					  when  PROP_CONTR_1 => next_state <= PROP_CONTR_2;
					  
					  when  PROP_CONTR_2 => if Out_C2 = "0000000000" then
					                        next_state <= INT_CONTR_0;
					                        else
														    next_state <= INT_CONTR;
													     end if;
													     
						when  INT_CONTR_0 => next_state <= DIFF_CONTR;
					  
					  when  INT_CONTR => if Out_C2 = "0000000000" then
					                        next_state <= INT_CONTR_0;
					                        else
														    next_state <= INT_CONTR;
													     end if;
																																								
					  when  DIFF_CONTR => next_state <= WR_MEM_B ;
					  
					  when  WR_MEM_B=> if   Out_C1 = "1111111111" then
														next_state <= RD_MEM_B;
													else
														next_state <= PROP_CONTR_0;
													end if;
													
						when RD_MEM_B => if   Out_C1 = "1111111111" then
														next_state <= DONE;
													else
														next_state <= RD_MEM_B;
													end if;
													
					  WHEN DONE => if Start = '1' then
											next_state <= DONE;
										else
											next_state <= IDLE;
										end if;
													
					  WHEN OTHERS => NEXT_STATE <= IDLE;
						
					END CASE;
					
				END PROCESS ;
				
						
			FSM_outputs : PROCESS ( PRESENT_STATE )
			
						BEGIN
						
							SUB_ADDn <= '0';
							RSTn_R_20bit <= '1';
							CS_MEM_B <= '0';
							Done_sign <= '0';
							EN_R_8bit <= '0';
							EN_C2 <= '0';
							MUX_Sel_Counters <= '0';
							
							CASE PRESENT_STATE IS
							
									WHEN IDLE => 
											EN_C1 <= '0';
											EN_C2 <= '0';
											CS_MEM_A <= '0';
											CS_MEM_B <= '0';
											Done_sign <= '0';
											EN_R_8bit <= '0';
											
									WHEN WR_MEM_A => 	
											EN_C1 <= '1';
											CS_MEM_A <= '1';
											RD_WRn_MEM_A <= '0';
											
									WHEN PROP_CONTR_0 =>
											EN_R_8bit <= '1';
											EN_C1 <= '0';
											L_C2 <= '1';
											RD_WRn_MEM_A <= '1';
											RSTn_R_20bit <= '0';
											
									WHEN PROP_CONTR_1 =>
									    EN_R_8bit <= '1';
											L_C2 <= '0';
											SUB_ADDn <= '0';
											MUX_Sel_adder <= "01";
											
									WHEN PROP_CONTR_2 =>
											MUX_Sel_adder <= "10";
											
									WHEN INT_CONTR_0 =>
									    EN_C2 <= '0';
									    MUX_Sel_Counters <= '1';
									    MUX_Sel_adder <= "00";
									    
									WHEN INT_CONTR =>
									    EN_C2 <= '1';
											MUX_Sel_Counters <= '1';
											MUX_Sel_adder <= "00";
											
									WHEN DIFF_CONTR =>
											MUX_Sel_adder <= "11";
											SUB_ADDn <= '1';
											
									WHEN WR_MEM_B => 
											CS_MEM_B <= '1';
											RD_WRn_MEM_B <= '0';
											EN_C1 <= '1';
											
									WHEN RD_MEM_B =>
									    CS_MEM_B <= '1';
											RD_WRn_MEM_B <= '1';
											EN_C1 <= '1';
											
									WHEN DONE =>
											Done_sign <= '1';
											EN_C1 <= '0';
									    EN_C2 <= '0';
									    EN_R_8bit <= '0';
									    CS_MEM_A <= '0';
									    CS_MEM_B <= '0';
									    RSTn_R_20bit <= '0';									    
									    
									WHEN OTHERS => 
											EN_C1 <= '0';
											EN_C2 <= '0';
											CS_MEM_A <= '0';
											CS_MEM_B <= '0';
											Done_sign <= '0';
											EN_R_8bit <= '0';
											
							END CASE;
							
					END PROCESS;
					
END Structure;
